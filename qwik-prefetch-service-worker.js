(()=>{const t=Number.MAX_SAFE_INTEGER>>>1;function n(n,i){const[o,s]=a(i),c=n.t.find((t=>o===t.i));if(c)return n.o("intercepting",i.pathname),e(n,c,[s],t).then((()=>function(t,n){const e=t.u.find((t=>t.l.pathname===n.pathname));return e?e.h.then((t=>t.clone())):(t.o("CACHE HIT",n.pathname),t.$(n))}(n,i)))}async function e(n,e,o,a){const c=new Set;o.forEach((t=>s(e.p,c,t))),await Promise.all(Array.from(c).map((i=>async function(n,e,i){let o=n.u.find((t=>t.l.pathname===e.pathname));const s=i>=t?"direct":"prefetch";if(o){const t=o.m?"fetching":"waiting";o.C<i?(n.o("queue update priority",t,e.pathname),o.C=i):n.o("already in queue",s,t,e.pathname)}else await n.$(e)||(n.o("enqueue",s,e.pathname),o={C:i,l:e,T:null,h:null,m:!1},o.h=new Promise((t=>o.T=t)),n.u.push(o));return o}(n,new URL(e.i+i,n.l),a)))),i(n)}function i(n){n.u.sort(o);let e=0;for(const o of n.u)if(o.m)e++;else if(e<n.v||o.C>=t){o.m=!0,e++;const s=o.C>=t?"FETCH (CACHE MISS)":"FETCH";n.o(s,o.l.pathname),n.H(o.l).then((async t=>{o.T(t),200===t.status&&(n.o("CACHED",o.l.pathname),await n.R(o.l,t.clone()))})).finally((()=>{n.o("FETCH DONE",o.l.pathname),n.u.splice(n.u.indexOf(o),1),i(n)}))}}function o(t,n){return n.C-t.C}function s(t,n,e){if(!n.has(e)){n.add(e);let i=t.findIndex((t=>t===e));if(-1!==i)for(;"number"==typeof t[++i];)s(t,n,t[t[i]])}return n}function a(t){const n=new URL(t).pathname,e=n.lastIndexOf("/");return[n.substring(0,e+1),n.substring(e+1)]}const c=(...t)=>{console.log("⚙️ Prefetch SW:",...t)};async function r(t,n,e,i){const o=t.t.findIndex((t=>t==t));if(-1!==o&&t.t.splice(o,1),t.o("adding base:",n),t.t.push({i:n,p:e}),i){const i=new Set(e.filter((t=>"string"==typeof t))),o=await t.S();for(const e of await o.keys()){const[s,c]=a(new URL(e.url)),r=[];s!==n||i.has(c)||(t.o("deleting",e.url),r.push(o.delete(e))),await Promise.all(r)}}}function u(t,n,i){const o=t.t.find((t=>n===t.i));o?e(t,o,i,0):console.error(`Base path not found: ${n}, ignoring prefetch.`)}function f(t){if(!t.U&&t.L.length){const e=t.L.shift();t.U=(async(t,e)=>{const i=e[0];t.o("received message:",i,e[1],e.slice(2)),"graph"===i?await r(t,e[1],e.slice(2),!0):"graph-url"===i?await async function(t,e,i){await r(t,e,[],!1);const o=await n(t,new URL(e+i,t.l));if(o&&200===o.status){const n=await o.json();n.push(i),await r(t,e,n,!0)}}(t,e[1],e[2]):"prefetch"===i?await u(t,e[1],e.slice(2)):"prefetch-all"===i?await function(t,n){const e=t.t.find((t=>n===t.i));e?u(t,n,e.p.filter((t=>"string"==typeof t))):console.error(`Base path not found: ${n}, ignoring prefetch.`)}(t,e[1]):"ping"===i?c("ping"):"verbose"===i?(t.o=c)("mode: verbose"):console.error("UNKNOWN MESSAGE:",e)})(t,e).then((()=>{t.U=null,f(t)}))}}class l{constructor(t,n,e=10,i=null,o=null,s=[],a=[],c=[]){this.H=t,this.l=n,this.v=e,this.A=i,this.U=o,this.u=s,this.t=a,this.L=c}S(){return this.A}async R(t,n){return(await this.S()).put(t,n)}async $(t){return(await this.S()).match(t)}o(){}}(t=>{const e=(i=t.fetch.bind(t),o=new URL(t.location.href),new l(i,o));var i,o;e.S=()=>e.A?e.A:(clearTimeout(void 0),setTimeout((()=>{e.A=null}),5e3),t.caches.open("QwikBundles")),t.addEventListener("fetch",(t=>{const i=t.request;if("GET"===i.method){const o=n(e,new URL(i.url));o&&t.respondWith(o)}})),t.addEventListener("message",(t=>{e.L.push(t.data),f(e)})),t.addEventListener("install",(()=>{t.skipWaiting()})),t.addEventListener("activate",(n=>{e.S=()=>e.A?e.A:(clearTimeout(void 0),setTimeout((()=>{e.A=null}),5e3),t.caches.open("QwikBundles")),n.waitUntil(t.clients.claim())}))})(globalThis)})();